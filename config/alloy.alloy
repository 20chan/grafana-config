logging {
  level = "info"
  format = "logfmt"
}

livedebugging {
  enabled = true
}

// otel
otelcol.receiver.otlp "default" {
	grpc {
    endpoint = "0.0.0.0:4317"
  }
	http {
    endpoint = "0.0.0.0:4318"
  }

	output {
		// metrics = [otelcol.processor.batch.default.input]
    // logs = [otelcol.processor.batch.default.input]
		// traces  = [otelcol.processor.batch.default.input, otelcol.connector.servicegraph.default.input]

		metrics = [otelcol.exporter.prometheus.default.input]
    logs = [otelcol.exporter.loki.default.input]
		traces  = [otelcol.connector.spanlogs.default.input, otelcol.exporter.otlp.tempo.input, otelcol.connector.servicegraph.default.input]
	}
}

/*
otelcol.processor.batch "default" {
	timeout             = "1s"
	send_batch_size     = 8192
	send_batch_max_size = 0

	output {
		metrics = [otelcol.exporter.otlp.tempo.input]
    logs = [otelcol.processor.attributes.default.input]
		traces  = [otelcol.connector.spanlogs.default.input, otelcol.exporter.otlp.tempo.input]
	}
}
*/

otelcol.connector.spanlogs "default" {
  spans = true
  roots = true
  processes = true
  events = true

  span_attributes = ["http.method", "http.target", "http.status_code"]

  output {
    logs = [otelcol.processor.attributes.default.input]
  }
}

otelcol.connector.servicegraph "default" {
  output {
    metrics = [otelcol.exporter.prometheus.default.input]
  }
}

otelcol.exporter.otlp "tempo" {
	client {
		endpoint = "tempo:4317"

		tls {
			insecure = true
      insecure_skip_verify = true
		}
	}
}

otelcol.processor.attributes "default" {
  action {
    key = "loki.attribute.labels"
    action = "insert"
    value = "event.domain, event.name"
  }

  action {
    key = "loki.resource.labels"
    action = "insert"
    value = "service.name, service.namespace"
  }

  output {
    logs = [otelcol.exporter.loki.default.input]
  }
}

otelcol.exporter.loki "default" {
  forward_to = [loki.process.otel.receiver]
}

loki.process "otel" {
  stage.json {
    expressions = {
      "body" = "body",
      "traceid" = "traceid",
      "spanid" = "spanid",
      "severity" = "severity",
    }
  }

  stage.labels {
    values = {
      trace_id = "traceid",
      span_id = "spanid",
      severity = "severity",
    }
  }

  forward_to = [loki.write.default.receiver]
}

otelcol.exporter.prometheus "default" {
  forward_to = [prometheus.remote_write.default.receiver]
}

loki.source.syslog "rsyslog" {
  listener {
    address = "0.0.0.0:51893"
    labels = {
      source = "rsyslog",
      component = "loki.source.syslog",
      protocol = "tcp",
    }
  }

  forward_to = [loki.write.default.receiver]
}

// fail2ban logs
local.file_match "fail2ban" {
  path_targets = [{
    __address__ = "localhost",
    __path__ = "/var/log/fail2ban.log",
    job = "fail2ban",
  }]
}

loki.process "fail2ban" {
  stage.multiline {
    firstline = "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}"
    max_wait_time = "10s"
  }

  stage.regex {
    expression = "^(?s)(?P<time>\\S+? \\S+?) (fail2ban\\.)(?P<component>\\S+)\\s* \\[(?P<pid>\\S+)\\]: (?P<priority>\\S+)\\s* (?P<message>.*?)$"
  }

  stage.timestamp {
    source = "time"
    format = "2006-01-02 15:04:05,000"
    location = "Local"
  }

  stage.output {
    source = "message"
  }

  stage.match {
    selector = "{job=\"fail2ban\"} |~ \"\\\\\\\\[\\\\\\\\S+\\\\\\\\] .*\""

    stage.regex {
      expression = "(\\[(?P<jail>\\S+)\\] )?(?P<message>.*?)$"
    }

    stage.labels {
      values = {
        jail = null,
      }
    }

    stage.output {
      source = "message"
    }
  }

  stage.regex {
    expression = ".*?(?P<remote_addr>\\d+\\.\\d+\\.\\d+\\.\\d+).*"
  }

  stage.geoip {
    db      = "/GeoLite2-City.mmdb"
    source  = "remote_addr"
    db_type = "city"
  }

  stage.labels {
    values = {
      geoip_city_name          = "",
      geoip_country_name       = "",
      geoip_country_code       = "",
      geoip_continent_name     = "",
      geoip_continent_code     = "",
      geoip_location_latitude  = "",
      geoip_location_longitude = "",
      geoip_postal_code        = "",
      geoip_timezone           = "",
      geoip_subdivision_name   = "",
      geoip_subdivision_code   = "",
    }
  }

  stage.label_drop {
    values = ["filename"]
  }

  forward_to = [loki.write.default.receiver]
}

loki.source.file "fail2ban" {
  targets = local.file_match.fail2ban.targets
  forward_to = [loki.process.fail2ban.receiver]
}

// docker metrics
prometheus.exporter.cadvisor "docker" {
  docker_host = "unix:///var/run/docker.sock"

  storage_duration = "1m"
}

discovery.relabel "docker" {
  targets = prometheus.exporter.cadvisor.docker.targets

  rule {
    target_label = "job"
    replacement  = "integrations/docker"
  }

  rule {
    target_label = "instance"
    replacement  = constants.hostname
  }
}

prometheus.scrape "docker" {
  targets = discovery.relabel.docker.output
  forward_to = [prometheus.remote_write.default.receiver]
}

// docker logs
discovery.docker "default" {
	host             = "unix:///var/run/docker.sock"
	refresh_interval = "5s"
}

discovery.relabel "logs_integrations_docker" {
	targets = []

	rule {
		source_labels = ["__meta_docker_container_name"]
		regex         = "/(.*)"
		target_label  = "container"
	}
}

loki.source.docker "default" {
	host             = "unix:///var/run/docker.sock"
	targets          = discovery.docker.default.targets
	forward_to       = [loki.write.default.receiver]
	relabel_rules    = discovery.relabel.logs_integrations_docker.rules
	refresh_interval = "5s"
}

loki.write "default" {
	endpoint {
		url       = "http://loki:3100/loki/api/v1/push"
		tenant_id = "fake"
    batch_wait = "1s"
    batch_size = "1MB"
	}
}

prometheus.remote_write "default" {
  endpoint {
    url = "http://prometheus:9090/api/v1/write"
  }
}
